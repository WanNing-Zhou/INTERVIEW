# 第一次面试总结



- [第一次面试总结](#第一次面试总结)
  - [1. react和vue怎么创建虚拟dom?](#1-react和vue怎么创建虚拟dom)
  - [2. diff算法](#2-diff算法)

## 1. react和vue怎么创建虚拟dom?   

**什么是虚拟DOM?**  
Virtual DOM是一颗以JavaScript对象作为基础的树,每一个节点称为VNode,用对象属性来描述节点,实际上它是一层真实DOM的抽象,最终可以通过渲染操作使这棵树映射到真实环境上,简单来说Virtual DOM就是Js对象,用以描述整个文档

**什么是真实DOM?**  
Real DOM,真实DOM,意思为文档对象模型,是一个结构化文本对象的抽象,在页面渲染出来的每一个结点都是一个真实DOM结构,如下:
![img.png](img.png)

**怎么将虚拟DOM转换成真实DOM?**
react和vue一样,都通过createElement的方式将虚拟dom转换为真实dom

**虚拟DOM作用**  
虚拟DOM的最终目标是将虚拟节点渲染到视图上,但是如果直接使用虚拟节点覆盖旧节点的化,会有很多不必要的DOM操作  

```text
例如，一个ul标签下很多个li标签，其中只有一个li有变化，这种情况下如果使用新的ul去替代旧的ul,因为这些不必要的DOM操作而造成了性能上的浪费。
```
为了避免不必要的DOM操作,虚拟DOM在虚拟节点映射到视图的过程中,将虚拟节点与上一次渲染视图所使用的旧虚拟节点(oldVnode)做对比,找出真正需要更新的节点来进行DOM操作,从而避免操作其他无需改动的DOM

虚拟DOM在Vue.js主要做了两件事情:  

- 提供与真实DOM节点所对应的虚拟节点vnode
- 将虚拟节点vnode和旧虚拟节点oldVnode进行对比,然后更新视图

**真实DOM与虚拟DOM的区别**  

- 虚拟DOM不会进行排版与重绘操作,而真实DOM会频繁重拍与重绘  
- 虚拟DOM的总损耗是"虚拟DOM增删改+真实DOM差异增删改+排版与重绘",真实DOM的总损耗是"真实DOM完全增删改+排版与重绘"  
  
```text
  传统的原生 api 或 jQuery 去操作 DOM 时，浏览器会从构建 DOM 树开始从头到尾执行一遍流程

当你在一次操作时，需要更新 10 个 DOM 节点，浏览器没这么智能，收到第一个更新 DOM 请求后，并不知道后续还有 9 次更新操作，因此会马上执行流程，最终执行 10 次流程

而通过 VNode，同样更新 10 个 DOM 节点，虚拟 DOM 不会立即操作 DOM，而是将这 10 次更新的 diff 内容保存到本地的一个 js 对象中，最终将这个 js 对象一次性 attach 到 DOM 树上，避免大量的无谓计算
```


**真实DOM与虚拟DOM优缺点**

真实DOM的优势:
- 易用
  

缺点:
- 效率低,解析速度慢,内存占用量过高
- 性能差: 频繁操作真实DOM,易于导致重绘与回流  
  

使用虚拟DOM的优势如下:

- 简单方便: 如果使用手动操作真实DOM来完成页面,繁琐又容易出错,在大规模应用下维护起来也很困难  
- 性能方面: 使用Virtual DOM能够有效避免真实DOM树频繁更新,减少多次引起重绘与回流, 提高性能
- 跨平台: React借助虚拟DOM,带来了跨平台的能力,一套代码多端运行  

缺点:  

- 在一些性能要求极高的应用中虚拟DOM无法进行针对性的极致优化
- 首次渲染大量DOM时,由于多了一层虚拟DOM的计算,速度比正常稍慢
  


## 2. diff算法

1. 是什么  

diff算法就是进行虚拟节点对比，并返回一个patch对象，用来存储两个节点不同的地方，最后用patch记录的消息去局部更新Dom。

简单来说Diff算法就是在虚拟DOM树从上至下进行同层比对，如果上层已经不同了，那么下面的DOM全部重新渲染。这样的好处是算法简单，减少比对次数，加快算法完成速度。


其有两个特点:  

- 比较只有会在同层级进行,不会跨层级比较
- 在diff比较的过程中,循环从两边向中间比较

diff算法在很多场景都有应用, 在vue中,作用域虚拟dom渲染成真实dom的新旧VNode节点比较



2. 从源码来分析diff算法

  

  vue在通过VNode节点渲染DOM时,并不是通过当前的VNode节点去暴力的更新DOM节点,

  而是对新旧两个VNode节点通过pathc算法进行比较,然后通过对比结果找出差异的节点进行按需更新;

  patch能够减少不必要的开销,提升性能

  

  patch的过程中主要完成以下几件事情:

  - 创建需要新增的节点,

  - 移除已经废弃的节点

  - 移动或修改需要更新的节点

  

  **及其重要的pathc函数**

  

  ![img_4.png](img_4.png)

这就是源码中: `patch`做的工作,具体呢,里面又含有`sameVnode`函数

```javascript
export function isSameVNodeType(n1: VNode, n2: VNode): boolean {
  return n1.type === n2.type && n1.key === n2.key
}

```

> 即: `旧节点的key`要和`新节点的key`相同,且旧节点的选择器要和新节点的选择器相同



**Vue3 的 patch 优化 -- patchFlag**



>  pathcFlags是什么? 



```ts
export const enum PatchFlags {
  // 动态文字内容
  TEXT = 1,

  // 动态 class
  CLASS = 1 << 1,

  // 动态样式
  STYLE = 1 << 2,

  // 动态 props
  PROPS = 1 << 3,

  // 有动态的key，也就是说props对象的key不是确定的
  FULL_PROPS = 1 << 4,

  // 合并事件
  HYDRATE_EVENTS = 1 << 5,

  // children 顺序确定的 fragment
  STABLE_FRAGMENT = 1 << 6,

  // children中有带有key的节点的fragment
  KEYED_FRAGMENT = 1 << 7,

  // 没有key的children的fragment
  UNKEYED_FRAGMENT = 1 << 8,

  // 只有非props需要patch的，比如`ref`
  NEED_PATCH = 1 << 9,

  // 动态的插槽
  DYNAMIC_SLOTS = 1 << 10,

  // SPECIAL FLAGS -------------------------------------------------------------

  // 以下是特殊的flag，不会在优化中被用到，是内置的特殊flag

  // 表示他是静态节点，他的内容永远不会改变，对于hydrate的过程中，不会需要再对其子节点进行diff
  HOISTED = -1,

  // 用来表示一个节点的diff应该结束
  BAIL = -2,
}
```

以上就是所有的pathcFlags, 和它的名字含义一致, 他就是一系列的标志,来表示要给节点该如何进行更新的



使用 `class = 1 << 1`这样的方式来表示的好处:



1. 很容易进行符合, 可以通过`TEXT|CLASS`来得到`0000000011`这个可以表示他既有`TEXT`的特性,也有`CLASS`的特性

2. 方便进行对比,我们拿到一个值`FLAG`的时候,想要判断它有没有`TEXT`的属性,只需要`FLAG&TEXT>0`就可以了
3. 方便扩展, 子啊足够位数的情况下,我们新增一种特性就之哟啊让他左移的位数加一就不会重复

这种方式起始很常见,比如我们做一个系统的权限管理的时候也会考虑这么做,在REACT里面这种凡是也有很多应用

> patchFlags有什么用?

首先,在`creawteVnode`的时候,会把`patchFlags`相关的参数都放到`vnode`对象里面:

```typescript
const vnode: VNode = {
  // ... other vnode attrs
  patchFlag,
  dynamicProps,
  dynamicChildren: null,
};
```

那他们啥时候被用到呢,主要是在节点被更新的时候,比如 `patchElement`  

```typescript
const patchElement = (
  n1: VNode,
  n2: VNode,
  parentComponent: ComponentInternalInstance | null,
  parentSuspense: SuspenseBoundary | null,
  isSVG: boolean,
  optimized: boolean
) => {
  const el = (n2.el = n1.el!);
  let { patchFlag, dynamicChildren, dirs } = n2;
  // #1426 take the old vnode's patch flag into account since user may clone a
  // compiler-generated vnode, which de-opts to FULL_PROPS
  patchFlag |= n1.patchFlag & PatchFlags.FULL_PROPS;

  if (patchFlag > 0) {
    if (patchFlag & PatchFlags.FULL_PROPS) {
      // element props contain dynamic keys, full diff needed
      patchProps();
      // ...args
    } else {
      if (patchFlag & PatchFlags.CLASS) {
        if (oldProps.class !== newProps.class) {
          hostPatchProp(el, "class", null, newProps.class, isSVG);
        }
      }
      if (patchFlag & PatchFlags.STYLE) {
        hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
      }

      if (patchFlag & PatchFlags.PROPS) {
        // if the flag is present then dynamicProps must be non-null
        const propsToUpdate = n2.dynamicProps!;
        // update props
      }
    }

    if (patchFlag & PatchFlags.TEXT) {
      if (n1.children !== n2.children) {
        hostSetElementText(el, n2.children as string);
      }
    }
  } else if (!optimized && dynamicChildren == null) {
    // unoptimized, full diff
    patchProps();
    // args
  }

  const areChildrenSVG = isSVG && n2.type !== "foreignObject";
  if (dynamicChildren) {
    patchBlockChildren();
    // ...args
    if (__DEV__ && parentComponent && parentComponent.type.__hmrId) {
      traverseStaticChildren(n1, n2);
    }
  } else if (!optimized) {
    // full diff
    patchChildren();
    // ...args
  }

  if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
    queuePostRenderEffect(() => {
      vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
      dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
    }, parentSuspense);
  }
};

```



这里的核心思想就是: **会根据`vnode`的`patchFlag`上具有的属性来执行不同的patch方法**,如果没有`patchFlag`那么就执行`full diff`,也就是这里的`patchProps`,那么也就会知道, `patchProps`应该包含了下面大部分的单个`patch`即:

- patchClass
- patchStyle
- patchEvent
- 等等



> patchFlags的规则



这里我们就拿几个常见的规则来讲以下`patchFlags`到底是怎么用的

模板: 

```html
<template>
  <div>{{name}}</div>
</template>
```

编译: 

```js
createElement("div", null, [name], PatchFlags.TEXT);
```

模板:

```html
<template>
  <div :class="classNames">{{name}}</div>
</template>
```

编译:

```js
createElement(
  "div",
  { class: classNames },
  [name],
  PatchFlags.TEXT | PatchFlags.CLASS
);
```

模板:

```html
<template>
  <div :class="classNames" :id="id">{{name}}</div>
</template>
```

编译:

```js
createElement(
  "div",
  { class: classNames, id: id },
  [name],
  PatchFlags.TEXT | PatchFlags.CLASS | PatchFlags.PROPS,
  ["id"] // 标明具体那几个props是动态的
);
```

模板: 

```html
<template>
  <div :[foo]="bar">Hello</div>
</template>
```

编译:

```js
createElement("div", { [foo]: bar }, ["Hello"], PatchFlags.FULL_PROPS);
```



**patch 是怎么工作的**



patch源码: 

```typescript
const patch: PatchFn = (
  n1,
  n2,
  container,
  anchor = null,
  parentComponent = null,
  parentSuspense = null,
  isSVG = false,
  slotScopeIds = null,
  optimized = false
) => {
  // patching & 不是相同类型的 VNode，则从节点树中卸载
  if (n1 && !isSameVNodeType(n1, n2)) {
    anchor = getNextHostNode(n1)
    unmount(n1, parentComponent, parentSuspense, true)
    n1 = null
  }
	// PatchFlag 是 BAIL 类型，则跳出优化模式
  if (n2.patchFlag === PatchFlags.BAIL) {
    optimized = false
    n2.dynamicChildren = null
  }

  const { type, ref, shapeFlag } = n2
  switch (type) { // 根据 Vnode 类型判断
    case Text: // 文本类型
      processText(n1, n2, container, anchor)
      break
    case Comment: // 注释类型
      processCommentNode(n1, n2, container, anchor)
      break
    case Static: // 静态节点类型
      if (n1 == null) {
        mountStaticNode(n2, container, anchor, isSVG)
      }
      break
    case Fragment: // Fragment 类型
      processFragment(/* 忽略参数 */)
      break
    default:
      if (shapeFlag & ShapeFlags.ELEMENT) { // 元素类型
        processElement(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        )
      } else if (shapeFlag & ShapeFlags.COMPONENT) { // 组件类型
        processComponent(/* 忽略参数 */)
      } else if (shapeFlag & ShapeFlags.TELEPORT) { // TELEPORT 类型
        ;(type as typeof TeleportImpl).process(/* 忽略参数 */)
      }
  }
}

```



解读: 

n1 与 n2 是待比较的两个节点, n1为旧几点, n2为新节点, container是新节点的一个容器,anchor是一个锚点, 用来表示我们对新旧系欸但做增删或移动操作时,以哪个节点为参照物, optimized参数是用来表示是否开启优化模式



第一个if条件,当旧节点存在,并且新旧节点不是同一类型时,则安静旧节点从节点数中卸载, 可以得到`patch`的**第一个逻辑: 当两个节点类型不同,则直接卸载旧节点**



第二个if分支,如果新节点的patchFlag为BAIL,优化模式会被关闭; 



接下来`pacht`函数会通过`switch case`来判断节点类型,并分别对不同类型节点类型执行不同的操作



> 元素的patch过过程 -- processElement



`processElement`这个函数本身的代码逻辑非常简单,总结起来就是:

如果存在旧节点则继续通过`patch`比较新旧两个节点;否则直接挂载新节点,

```typescript
const processElement = (
  n1: VNode | null,
  n2: VNode,
  container: RendererElement,
  anchor: RendererNode | null,
  parentComponent: ComponentInternalInstance | null,
  parentSuspense: SuspenseBoundary | null,
  isSVG: boolean,
  slotScopeIds: string[] | null,
  optimized: boolean
) => {
  // 如果旧节点不存在
  if (n1 == null) {
    mountElement(
      n2,
      container,
      anchor
      /* 后续参数省略 */
    )
  } else {
    patchElement(
      n1,
      n2,
      parentComponent,
      parentSuspense,
      isSVG,
      slotScopeIds,
      optimized
    )
  }
}
```



假设旧节点都是存在的,继续往下分析



>  比较子节点--patchElement



在元素类型的patch过程中,Vue3首先会将新旧节点的props声明提取出来,之后需要对props进行patch比较



在比较开始之前会触发一些钩子比如VNode自身的钩子`onVnodeBefroeUpdate`,以及元素上帮绑定的指令的钩子`beforeUpdate`

```typescript
    if ((vnodeHook = newProps.onVnodeBeforeUpdate)) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1)
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, 'beforeUpdate')
    }
```



> 更新属性

之后开始比较props,如果此时元素被标记过`patchFlag`或,则会通过`patchFlag`进行按需比较,否则会全量的diff元素中的props

```typescript
if (patchFlag > 0) {
  if (patchFlag & PatchFlags.FULL_PROPS) {
    // 如果元素的 props 中含有动态的 key，则需要全量比较
    patchProps(
      el,
      n2,
      oldProps,
      newProps,
      parentComponent,
      parentSuspense,
      isSVG
    )
  } else {
    if (patchFlag & PatchFlags.CLASS) {
      if (oldProps.class !== newProps.class) {
        hostPatchProp(el, 'class', null, newProps.class, isSVG)
      }
    }

    if (patchFlag & PatchFlags.STYLE) {
      hostPatchProp(el, 'style', oldProps.style, newProps.style, isSVG)
    }

    if (patchFlag & PatchFlags.PROPS) {
      const propsToUpdate = n2.dynamicProps!
      for (let i = 0; i < propsToUpdate.length; i++) {
        const key = propsToUpdate[i]
        const prev = oldProps[key]
        const next = newProps[key]
        if (
          next !== prev ||
          (hostForcePatchProp && hostForcePatchProp(el, key))
        ) {
          hostPatchProp(
            el,
            key,
            prev,
            next,
            isSVG,
            n1.children as VNode[],
            parentComponent,
            parentSuspense,
            unmountChildren
          )
        }
      }
    }
  }

  if (patchFlag & PatchFlags.TEXT) {
    if (n1.children !== n2.children) {
      hostSetElementText(el, n2.children as string)
    }
  }
} else if (!optimized && dynamicChildren == null) {
  patchProps(
    el,
    n2,
    oldProps,
    newProps,
    parentComponent,
    parentSuspense,
    isSVG
  )
}

```

解读: 

- 当patchFlag 为 FULL_PROPS时,说明此时的元素中,可能包含了动态的key,需要进行全量的`props diff`
- 当patchFlag 为 CLASS 时, 当新旧节点的 class 不一致时,此时会对 class 进行patch,而当新旧节点的class属性完全一致时,不需要进行任何操作,这个Flag标记会在 元素有动态的class绑定时加如
- 当patchFlag为 STYLE 时, 会对 style 进行更新,这是每次patch都会进行的,这个FLAG会在有动态style绑定时被加如
- 当patchFlag为PROPS时,需要注意这个Flag会在元素拥有动态的属性或者attrs绑定时添加,不同于class和style,这些动态的prop或attrs的key会被保存下来以便于更快速的迭代
  - PROPS 的比较会讲新节点的动态属性提取出来,并遍历整个属性中所有的key,当新旧属性不一致,或者key需要强制更新时,则调用`hostPatchProp`对属性进行更新  
- 当patchFlag为TEXT时,如果新旧节点中的子节点时文本发生变化,则调用hostSetElementTest进行更新,这个flag会在元素的子节点只包含动态文本时被添加



此时当元素拥有patchFlag的分支判断就结束了,我们可以在这些分支判断中,体会到patchFlag为patch算法的速度提升所做出的努力



分支走到最后一个else, 若当前不存在优化标记并且动态子节点也不存在,则直接对props进行全量 diff 通过patchProps这个安徽拿书完成



> 更新子节点--patchChildren



在元素patch过程中,会判断是否存在动态子节点,如果是则调用patchBlockChildren仅仅更新动态的子节点,否则会调用patchChildren对子节点进行全量更新  



在更新子节点时,受下也是利用patchFlag的能力,对子节点进行分类做出不同的处理;







一般情况: patchChildren

在更新子节点时,首先也是利用 patchFlag 的能力, 对子节点进行分类做出

不同, patchChildren函数的逻辑



- 根据`patchFlag`进行判断
  - 如果`patchFlag`是存在key只得Fragment: KEYED_FRAGMENT,则调用 `patchKeyedChildren来继续处理子节点
  - 如果`patchFlag`是没有设置key值得 Fragment: UNKEYED_FRAGMENT 则 调用 `patchUnkeyedChildren`处理没有key值得子节点
- 根据shapFlag(元素类型标记)进行判断:
  - 如果新子节点是文本类型,而旧节点是数组类型,则直接卸载旧节点得子节点
    - 如果新旧节点类型一致,则直接更新子节点得文本
  - 如果旧子节点是数组类型
    - 如果新子节点也是数组类型,则调用 `patchKeyedChildren`进行完整得diff
    - 如果新子节点是数组类类型,而旧子节点不是,说明此时需要在树种挂载新子节点,进行mount操作



上面就是	patchChildren 的完整逻辑,  这里最复杂的就是当新旧节点都为数组类型的时候调用`patchKeyedCildren`对两个数组进行完全比较



**子节点的更新策略**

如何高效的做diff算法,最重要的性能瓶酒就是如何更快速的对树种的子节点进行比较,得出需要进行什么操作,如果按照正常思维去比较,那么这个时间复杂度至少为O(n^3),这个操作无疑是非常昂贵的;

而针对这种情况如何实现一个时间复杂度为O(n)的短发,就是前端框架必须考虑的问题, 与react一样,Vue种也有key来协助标识子节点,帮助框架进行高效的识别和比较子节点



> Vue2 的子节点优化策略

《深入浅出 Vue.js 》这本书中，作者刘博文将 Vue2 的子节点优化策略总结为四类：

- 新前与旧前
- 新后与旧后
- 新后与旧前
- 新前与旧后

需要注意的是新前指代新子节点索引在最前面的节点，而新后指代新子节点索引在末尾的节点，而旧则指代旧子节点的意思。



| Vue3 的子节点更新

```typescript
const patchKeyedChildren = (
  c1: VNode[],
  c2: VNodeArrayChildren,
  container: RendererElement,
  parentAnchor: RendererNode | null,
  parentComponent: ComponentInternalInstance | null,
  parentSuspense: SuspenseBoundary | null,
  isSVG: boolean,
  slotScopeIds: string[] | null,
  optimized: boolean
) => {
  let i = 0 //遍历子节点的索引
  const l2 = c2.length
  let e1 = c1.length - 1 // prev ending index
  let e2 = l2 - 1 // next ending index
  /* 忽略后续逻辑 */
}
```



首先来看patchKeyedChildren的函数签名部分, 该函数参乎中的c1,c2分别代表旧子节点



- 第一个比较策略 新前与旧前
![img_5.png](img_5.png)
  

  





## ci/cd流 ?
