# 美团面经总结


## 页面滚动会造成回流吗:

也买你滚筒通常不会造成回流, 回流发生在改变页面的饿集合属性(大小,未知,边距等), 这些改变需要重新计算元素的
集合属性和页面的布局: 但是, 当滚动页面时, 页面的集合属性不会改变,只是视口发生了移动, 因此不会导致回流

## display: none 和 visibility:hidden 的区别

display: bone 回完全经元素从文档流中移除, 该元素占据的空间也会消失; 这意味着其他元素可以占据该元素原本占据的空间;
同时, 该元素不会响应用户事件, 比如点击,键盘输入等

visbility: hidden会将元素隐藏但是不会将其从文档流中移除, 因此该元素仍然占据着他原本的空间, 其他元素无法占据
元素的空间, 因此页面布局不会改变, 同时, 该元素依然回响应用户事件

总的来说: 如果想让元素彻底从页面上移除并释放其占用的空间,那么可以使用display: none; 如果想让元素在页面上
消失但依然占其原有空间, 那么使用visibility: hidden


visibility: hidden 常常比 display: none 对于性能更好,但如果要频繁地在元素间进行切换, 那么该属性可能会对页面性能产生一定的影响



## visible: hidden 会造成重排

不会

## v-if false 是设置的display: none吗

v-if 是 vue.js框架提供的一个质量,用于根据某种条件判断是否渲染某个元素, 如果条件为真则渲染该元素,
如果为假则将该元素从DOM中移除


使用v-if指令奖一个元素从dom树种移除时, 不同于display: none 样式, 他不会保留该元素任何渲染西悉尼,也不会占据空间;

这就意味着, 使用 v-if 指令奖一个元素从DOM种移除时, 它奖无法在页面上访问, 也不会影响页面布局或性能;
当条件满足时, vue.js将重新生成并渲染该元素

**v-if=false 的元素会出现在虚拟dom种吗?**

在vue.hs使用v-if指令将一个元素从dom种移除, vue.js将其标记为已经卸载并从虚拟DOM中删除, 也就是说
当条件设置为false时, 使用v-if指令所隐藏的元素将从虚拟DOM中完全删除, 它们不会出现在任何渲染周期中

这与v-show指令不同, v-show指令不会将元素从DOM中移除, 而仅仅将其设置为display: none, 
这就意味着在条件为false时仍然存在于虚拟DOM中,只是在渲染时不会再页面上显示

因此使用v-if指令将元素从DOM中完全移除, 以减少虚拟DOM中的更新和渲染开销, 当然也可以提高性能,
但是, 与v-show不同, 每次元素重新渲染时, 都需要重新加载元素所有事件监听的状态, 因此再性能和使用方面
需要根据具体情况进行权衡




## 浏览器的渲染过程 

浏览器的渲染过程分为以下几步：

1.解析HTML，构建DOM树

2.解析CSS样式表，构建CSSOM(CSS Object Model)

3.将DOM和CSSOM进行合并生成Render Tree(渲染树)

4.根据Render Tree计算布局

5.依据Render Tree进行渲染


## 对于虚拟DOM的理解

Vue 使用虚拟 DOM 来提高性能和渲染速度。虚拟 DOM 是一个内存中的树型结构，它通过与浏览器 DOM 进行对比，来计算出最小化的修改来更新浏览器中的 DOM 元素。它的实现通常分为以下步骤：

初始渲染：在 Vue 实例创建时，会进行一次初始渲染，将数据渲染成虚拟 DOM。

更新虚拟 DOM：当数据发生改变时，Vue 会对新数据进行 diff 算法比较，生成新的虚拟 DOM 树。

计算出差异：对比两个虚拟 DOM 树，生成差异操作对象并存储。

批量更新：对于需要修改的 DOM 元素，采用一种批量的、异步的方式进行更新。

使用虚拟 DOM 可以有效地避免频繁地操作 DOM 元素，从而提高浏览器的性能和渲染速度。由于虚拟 DOM 只在数据发生修改时才会生成新的虚拟 DOM 并进行对比，因此它也不会影响到界面的响应速度。

值得注意的是，虚拟 DOM 并不是完全的代替了真实的 DOM 操作，实际上，虚拟 DOM 的生成、对比和操作也需要一定的计算资源。因此，在处理小规模数据或者需要频繁更新的情况下，并不一定比直接操作 DOM 更优秀。使用虚拟 DOM 的场景，通常是需要处理大量数据或者需要对界面进行频繁更新时。

## 前端如何减少打包体积


前端减少打包体积的方法有很多，从代码层面、依赖层面、构建层面多个方面考虑。

代码层面：尽量减少冗余代码，避免重复编写相同的代码，使用函数封装、组件化等方式提高代码重用性。特别是对于一些复杂的算法和逻辑代码，可以考虑通过分析和优化，减少代码的量和达到更优的运行效率。对于低优先级的代码，可以通过懒加载来延迟加载，减少首屏加载时间。

依赖层面：审视项目中依赖的第三方库和框架，根据需求对其中的一些模块进行按需加载。对于一些不必要的依赖和插件，尽量剔除掉。同时精简依赖，剔除不必要的语言包和样式文件也是提高前端作用的重要一步。

构建层面：优化构建工具的配置，开启现代化浏览器支持能力和代码压缩等优化，减小打包的体积。使用 Tree-Shaking 和按需加载等技术来减少未使用代码的打包，对图片、字体等文件进行优化和压缩，减小文件大小。另外，使用 CDN 来分担服务器的负荷和减小首屏加载时间。

数据层面：在前端页面中，一些用户数据如果不必要必须加载到客户端，就可以为用户节省很大的加载时间，从从而延长用的使用体验。

需要注意的是，在优化打包体积的过程中，我们必须保证功能和性能的完整性。不能因为优化打包体积而导致影响项目的正常运行，同时对于优化的成果也要进行测试和评估。

## http强缓存和协商缓存

HTTP 的缓存机制分为强缓存和协商缓存，二者均为缓存机制的一种，不过在具体实现和使用方面不同。

强缓存：客户端在向服务器请求资源时，如果发现请求的资源在本地缓存中，
则直接使用本地缓存而不向服务器发出请求，
从而减少不必要的网络流量和服务器负载。
强缓存的验证规则有两个：Expires 和 Cache-Control。
其中 Expires 是一种比较老的方式，由服务器发出响应时告诉浏览器资源的过期时间，
浏览器在之后重新请求该资源时，会根据该时间来判断是否需要向服务器发请求，
但是由于过期时间是由服务器控制且依赖于本地时间，
所以会有一定的误差。
而Cache-Control 相对于 Expires 更加灵活，
它支持多种形式的过期时间设置，
比如设置缓存存储的最长时间 max-age（单位为秒），
可以设置为 public 表示资源可以被缓存，
也可以设置为 private 表示只有特定用户才能缓存该资源等。
由于是在 HTTP 协议中信息中标记缓存，
因此不受本地时间等其它因素影响。

协商缓存：
协商缓存是在强缓存失效的情况下，
服务器与浏览器重新协商来确定该资源是否需要更新的一种缓存机制。
在协商缓存中，浏览器会在发出请求时将自己的缓存信息以 
If-Modified-Since 和If-None-Match 的形式带入请求头，
分别表示上一次请求该资源的时间和上一次请求该资源时服务器返回的 Etag（资源的唯一标识）。
服务器通过比对这些信息，判断是否需要重新发出响应，如果资源没有发生变化
（Etag 没有改变或者 If-Modified-Since 时间还未到达），
则返回 304 Not Modified 响应码，
否则服务器会直接返回新的资源。
在协商缓存中，服务器需要先获取一下用户请求的缓存的信息是否有更新，
如果没有更新是不会重新请求资源。
这就更加减少了不必要的网络流量和服务器负担。
