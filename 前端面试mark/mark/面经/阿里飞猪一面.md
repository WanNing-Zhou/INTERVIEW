#  阿里飞猪一面

## 1. js this的指向取决于哪些因素

JavaScript中，this关键字的指向是根据函数的调用方式来决定的，具体取决于以下几个因素：

1. 函数的调用方式：this的指向取决于函数的调用方式，主要有四种调用方式：

函数调用（函数作为普通函数调用，即直接使用函数名调用）
方法调用（函数作为对象的方法调用，即通过对象调用该函数）
构造函数调用（通过new关键字创建函数的实例对象）
apply/call/bind调用（使用apply、call或bind方法手动指定函数的this指向）

2. 函数所属的对象：如果函数是作为对象的方法被调用，this指向该对象。


3. 箭头函数：箭头函数中的this指向的是该函数定义时所在的作用域，而不是调用时的作用域。


4. 在严格模式下，函数中未指定this的情况下this为undefined。

总之，this的指向是JavaScript中一个比较复杂和灵活的概念，需要开发人员理解和掌握，以便更好地进行函数开发和调用。



## 2. 改变this指向 参数

call方法 传递的是参数列表

apply方法 传递的是数组

bind方法会创建一个新的函数, 并将器this之下那个绑定到的指定的对象, 该方法不会立即调用函数, 而是会返回新的函数

## 3. 事件得冒泡 如何阻止事件冒泡

事件冒泡是指当一个元素上的事件被触发后，该事件会向父级元素逐层传递，直到传递到document对象。
例如，当在一个按钮上点击时，点击事件会先在按钮上触发，然后逐级向上冒泡，直到传递到document对象。

stopPropagation()

## 4. 节流函数的原理 

节流函数是一种优化函数执行频率的方法，通过限制函数的调用频率来提高性能。其原理是在一定时间内，无论触发了多少次事件，函数只会执行一次。

```js
function throttle(fn, delay) {
  let timer = null

  return function() {
    const context = this
    const args = arguments

    if (!timer) {
      timer = setTimeout(() => {
        fn.apply(context, args)
        timer = null
      }, delay)
    }
  }
}
```
## 5. scss,less 的特点


## 6. 怎样理解html的语义化

总之，HTML的语义化是指在编写HTML代码时，使用有意义的标签和属性来描述文档结构和内容，
使得页面更加易于理解、访问和维护。
通过使用语义化的标签，可以提高页面的可访问性、可维护性和可读性，从而提高用户体验和开发效率。

## 7. display: none   vissable: hidden

display: none 不会占据空间, 在dom树中不会被构建

visibility: hidden  会占据空间, 会在dom树种构建

## 8. rem, px, em;

px：像素单位，是绝对单位。1px表示屏幕上的一个物理像素。通常用于定义固定大小的元素，例如边框或背景图像。
em：相对单位，基于元素的字体大小计算。1em等于元素的字体大小。如果父元素的字体大小为16px，则子元素设置为1em将等于16px。因此，em单位的值相对于其父元素的字体大小而言，可实现适应性布局。
rem：也是相对单位，与em类似，但是相对根元素(html元素) 的字体大小计算。例如，如果根元素的字体大小为16px，则元素设置为1rem将等于16px。与em相比，rem更适用于响应式设计中，因为它可以快速更改整个页面的字体大小，从而影响整个页面的布局

## 9. ui设计稿如何计算元素的 


1. 确认设计稿的像素尺寸
2. 将像素尺寸转换为相对单位
3. 确定根标签的字体大小: 
4. 计算相对单位的值(用到less/scss) 例如，如果根元素的字体大小为16px，则按钮宽度为100像素转换为rem单位的值为6.25rem（100像素/16像素=6.25rem）。



## 10. 如何进行深拷贝

1. JSON.parse(JSON.stringify(obj)) : 只适用于 JSON 对象和数组其他类型会在转换过程中丢失
2. 递归实现深拷贝
3. 使用第三方库实现深拷贝:  Lodash、Underscore

## 11. 如何规避对象深拷贝循环引用的影响

1. 手动检测循环引用

手动检测循环引用的方法是，遍历对象的属性时，记录下遍历过的对象，如果后续遍历过程中遇到了已经遍历过的对象，即表示出现了循环引用，此时可以直接返回该对象的引用，而不进行深拷贝。

2. 使用第三方库

许多第三方 JavaScript 库中都提供了防止循环引用的深拷贝方法，如 Lodash 库中的 _.cloneDeepWith 和 _.cloneDeep 方法。



## 12. promise .all 和 race 的区别; all的入参,  如果all中有一个rejected还会执行后面的吗, 


## 13. await 和 async 


## 14. js的事件循环

JavaScript 是单线程执行的语言，所有的代码都是按照顺序执行的。为了处理异步操作，
JavaScript 引入了事件循环机制，也称为 Event Loop。
事件循环是 JavaScript 运行时的一部分，用于监听执行队列中的事件并处理这些事件。
下面是 JavaScript 事件循环的基本流程。


1. 执行同步代码  
JavaScript 引擎首先会执行同步代码，包括函数调用、变量赋值等操作。

2. 执行微任务（Microtask）  
在同步代码执行结束后，JavaScript 引擎会立即执行所有的微任务。微任务是指 Promise 的回调函数、MutationObserver 的回调函数等。

3. 执行宏任务（Macrotask）  
在微任务执行完毕后，JavaScript 引擎会执行所有的宏任务。宏任务是指 setTimeout、setInterval、requestAnimationFrame、I/O 操作等。

4. 重复执行事件循环  
在宏任务执行完毕后，JavaScript 引擎会再次执行所有的微任务，然后再次执行所有的宏任务，不断重复这个过程。


在同步代码执行期间，即使有异步任务（如 setTimeout、Promise），它们也不会被执行。只有在同步代码执行完成后，才会执行异步任务。  

在执行微任务期间，如果又产生了新的微任务，会立即执行这些新的微任务，直到微任务队列为空。  

setTimeout、setInterval 等宏任务的执行顺序是由浏览器的事件循环实现决定的，不同浏览器的实现可能不同。  

Promise 构造函数中的代码是同步执行的，then 方法中的代码是异步执行的。

## 15. babel的原理  ??? (es6=>ATS=>es5)


Babel是一个JavaScript编译器, 可以将ES2015+代码转换为向后兼容的JavaScript代码, Babel的原理事件JAvaScript代码分为三个阶段: 解析, 转换和输出

1. 解析阶段

Babel首先会使用 Babylon 解析器将输出的ES 2015+diamagnetic解析成抽象语法树(AST), 抽象语法树是一种JSON形式表示的代码结构的数据结构,
他将代码分解成语法单元,并按照层次结构阻止起来,抽象语法树包含了代码的所有信息,包括变量,函数,语句等

2. 转换阶段

Babel的转换阶段但会遍历抽象语法树,并根据预设的转换规则,对代码进行转换; 转换规则是一组插件, 每个插件都可以针对不同的代码结构进行转换;

例如ES6的箭头函数在ES5中没有对应的语法, Babel的箭头函数插件会将箭头函数 转换为普通函数,Babel还支持自定义插件, 开发者可以根据自己的需求编写插件

3. 输出阶段

Babel的输出阶段会将转换后的抽象语法树转换为JavaScript代码, 输出格式可以是浏览器或者Node.js 可以执行的代码,
也可以是其他JavaScript的转换工具可以处理的代码格式, Babel也支持输出抽象语法树,方便开发者进行后续处理


> 总之Babel可以通过解析,转换,和输出三个阶段,将ES2015+ 代码转换为向后兼容的JavaScript代码, Babel的插件机制
> 使得它可以支持新的JavaScript特性, 并使得开发者可以根据自己的需求自定义转换规则



## 16. 计算网络模型
## 17. https的加密原理


## 18. 快排, 冒泡, 插入排序
## 19. 平衡二叉树`

平衡二叉树,是一种自平衡的二叉搜索树,它的左子树和右子树的高度差不超过1不,
这种特性可以保证二叉署到饿查找,键入和删除操作具有较号的事件复杂度,
最坏的情况下时间复杂度为 O(log n)

平衡二叉树的节点结构包含了左子树,右子树,节点值,节点高度等信息, 在平衡
二叉树中,每个几点是由器左右子树较高的那棵树的高度+1得到的,当平衡
二叉树的某个几点的左右子树高度差超过1时,需要通过旋转等操作来使其重新
平衡,以保证平衡二叉树的高度差不超过1

平衡二叉树的优点是能够高效地插入,查找,删除等操作,
并且相比于其他自平衡的二叉搜索树,平衡二叉树的实现较为简单,
缺点是需要维护节点的高度信息,因此会占用一定的额外空间,并且
在删除节点时可能需要进行多次旋转操作,影响性能

