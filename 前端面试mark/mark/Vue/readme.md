## 前端面试Vue部分总结
_____

本笔记由作者在复习前端Vue部分的相关的一些总结, 如果有什么错误的地方或者有什么相关的建议欢迎联系我

这份笔记借鉴了很多网上的文章, 如果有雷同或者相似的地方, 不用怀疑, 那就是搬得, 如果你是当中一些文章得作者,
如果觉得这种行为不恰当, 请与我联系, 收到消息后我会尽快处理

邮箱: zwn_fobj@foxmail.com

QQ: 1879154660  
QQ昵称: 只为你乱了浮生

感谢各位观看者的支持, 希望能对正在面临面试的你有所帮助,
____

## 目录 

- [一 Vue面试题<](#one)
    - [1. Vue优点?](#1)
    - [2. vue父组件向子组件传递数据？](#2)
    - [3. 子组件向父组件传递事件？](#3)
    - [4. v-show和v-if指令的共同点和不同点？](#4)
    - [5.如何让CSS只在当前组件中起作用？](#5) 
    - [6. keep-alive的作用是什么](#6)
    - [7. 如何获取dom?](#7)
    - [8. 说出几种vue当中的指令和它的用法？](#8)
    - [9. vue-loader是什么? 使用它的用途有哪些?](#9)
    - [10.为什么使用key?](#10)
    - [11.axios及安装?](#11)
    - [12. v-modal的使用。](#12)
    - [13.请说出vue.cli项目中src目录每个文件夹和文件的用法？](#13)
    - [14.分别简述computed和watch的使用场景](#14)
    - [16.$ nextTick的使用](#16)
    - [17. vue组件中data为什么必须是一个函数？](#17)
    - [18.渐进式框架的理解](#18)
    - [19.Vue中双向数据绑定是如何实现的？](#19)
    - [20.单页面应用和多页面应用区别及优缺点](#20)
  
- [二 声明周期函数面试题](#two)
    - [1.什么是 vue 生命周期？有什么作用？](#21)
    - [2.第一次页面加载会触发哪几个钩子？](#22)
    - [3.简述每个周期具体适合哪些场景](#15)
    - [4.created和mounted的区别](#23)
    - [5.vue获取数据在哪个周期函数](#24)
    - [6.请详细说下你对vue生命周期的理解？](#25)
  
- [三、vue路由面试题 ](#three)
    - [1.mvvm 框架是什么？](#26)
    - [2.vue-router 是什么?它有哪些组件<](#27)
    - [3.active-class 是哪个组件的属性？](#28)
    - [4.怎么定义 vue-router 的动态路由? 怎么获取传过来的值？](#29)
    - [5.vue-router 有哪几种导航钩子?](#31)
    - [6.$route 和 $router 的区别</h2>](#32)
    - [7.vue-router的两种模式](#33)
    - [8.vue-router实现路由懒加载（ 动态加载路由 ）](#34)
    
- [四, vuex常见面试题](#four)
    - [1. vuex是什么？怎么使用？哪种功能场景使用它？](#35)
    - [2.vuex有哪几种属性？](#36)
    - [3.Vue.js中ajax请求代码应该写在组件的methods中还是vuex的actions中？](#37)
    - []()
    - []()
    - []()
    - []()
    - []()
    - []()
    - []()
-----

# <h1 id="one">一 Vue面试题</h1>

## <h2 id="1">1. Vue优点?</h2>

答：轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十kb；  
简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；  
双向数据绑定：保留了angular的特点，在数据操作方面更为简单；   
组件化：保留了react的优点，实现了html的封装和重用，在构建单页面应用方面有着独特的优势；  
视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；   
虚拟DOM：dom操作是非常耗费性能的， 不再使用原生的dom操作节点，极大解放dom操作，但具体操作的还是dom不过是换了另一种方式；  
运行速度更快:相比较与react而言，同样是操作虚拟dom，就性能而言，vue存在很大的优势

## <h2 id="2">2. vue父组件向子组件传递数据？</h2>

通过props

## <h2 id="3">3. 子组件向父组件传递事件？</h2>

答：$emit方法

## <h2 id="4">4. v-show和v-if指令的共同点和不同点？</h2>

答:
共同点：都能控制元素的显示和隐藏；  

不同点：实现本质方法不同，v-show本质就是通过控制css中的display设置为none，
控制隐藏，只会编译一次；v-if是动态的向DOM树内添加或者删除DOM元素，若初始值为false，就不会编译了。
而且v-if不停的销毁和创建比较消耗性能。

总结：如果要频繁切换某节点，使用v-show(切换开销比较小，初始开销较大)。如果不需要频繁切换某节点使用v-if（初始渲染开销较小，切换开销比较大）。

## <h2 id="5">5.如何让CSS只在当前组件中起作用？</h2>

在组件中的style前面加上scoped

## <h2 id="6">6. keep-alive的作用是什么</h2>

keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。
## <h2 id="7">7. 如何获取dom?</h2>

答：ref=“domName” 用法：this.$refs.domName

## <h2 id="8">8. 说出几种vue当中的指令和它的用法？</h2>

答：
v-model双向数据绑定；  
v-for循环；  
v-if v-show 显示与隐藏；  
v-on事件；v-once: 只绑定一次。    

## <h2 id="9">9. vue-loader是什么? 使用它的用途有哪些?</h2>

答：vue文件的一个加载器，将template/js/style转换成js模块。  
用途：js可以写es6、style样式可以scss或less、template可以加jade等  

## <h2 id="10">10.为什么使用key?</h2>

答：需要使用key来给每个节点做一个唯一标识，Diff算法就可以正确的识别此节点。  
作用主要是为了高效的更新虚拟DOM。

## <h2 id="11">11.axios及安装?</h2>

答：请求后台资源的模块。npm install axios --save装好，  
js中使用import进来，然后.get或.post。返回在.then函数中如果成功，失败则是在.catch函数中。

## <h2 id="12">12. v-modal的使用。</h2>

答：
v-model用于表单数据的双向绑定，其实它就是一个语法糖，这个背后就做了两个操作：
v-bind绑定一个value属性；
v-on指令给当前元素绑定input事件。

## <h2 id="13">13.请说出vue.cli项目中src目录每个文件夹和文件的用法？</h2>

答：assets文件夹是放静态资源；components是放组件；router是定义路由相关的配置; app.vue是一个应用主组件；main.js是入口文件。

## <h2 id="14">14.分别简述computed和watch的使用场景</h2>

答：  
computed:  
当一个属性受多个属性影响的时候就需要用到computed  
最典型的栗子： 购物车商品结算的时候  
watch:  
当一条数据影响多条数据的时候就需要用watch  
栗子：搜索数据  

## <h2 id="16">16.$ nextTick的使用</h2>

答：当你修改了data的值然后马上获取这个dom元素的值，是不能获取到更新后的值，
你需要使用$nextTick这个回调，让修改后的data值渲染更新到dom元素之后在获取，才能成功。

## <h2 id="17">17.vue组件中data为什么必须是一个函数？</h2>

答：因为JavaScript的特性所导致，在component中，data必须以函数的形式存在，不可以是对象。  
组建中的data写成一个函数，数据以函数返回值的形式定义，这样每次复用组件的时候，都会返回一份新的data，  
相当于每个组件实例都有自己私有的数据空间，它们只负责各自维护的数据，不会造成混乱。而单纯的写成对象形式，就是所有的组件实例共用了一个data，
这样改一个全都改了

## <h2 id="18">18.渐进式框架的理解</h2>
答：主张最少；可以根据不同的需求选择不同的层级；
## <h2 id="19">19.Vue中双向数据绑定是如何实现的？</h2>

答：vue 双向数据绑定是通过 数据劫持 结合 发布订阅模式的方式来实现的，   
也就是说数据和视图同步，数据发生变化，视图跟着变化，视图变化，数据也随之发生改变；  
核心：关于VUE双向数据绑定，其核心是 Object.defineProperty()方法。

## <h2 id="20">20.单页面应用和多页面应用区别及优缺点</h2>

答：  
单页面应用（SPA），通俗一点说就是指只有一个主页面的应用，浏览器一开始要加载所有必须的 html, js, css。
所有的页面内容都包含在这个所谓的主页面中。但在写的时候，还是会分开写（页面片段），然后在交互的时候由路由程序动态载入，
单页面的页面跳转，仅刷新局部资源。多应用于pc端。  

多页面（MPA），就是指一个应用中有多个页面，页面跳转时是整页刷新  

单页面的优点：  
用户体验好，快，内容的改变不需要重新加载整个页面，基于这一点spa对服务器压力较小；前后端分离；页面效果会比较炫酷（比如切换页面内容时的专场动画）。  

单页面缺点：
不利于seo；导航不可用，如果一定要导航需要自行实现前进、后退。（由于是单页面不能用浏览器的前进后退功能，所以需要自己建立堆栈管理）；初次加载时耗时多；页面复杂度提高很多。

# <h1 id="two">声明周期函数面试题</h1>

## <h2 id="21">1.什么是 vue 生命周期？有什么作用？</h2>

答：每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。
同时在这个过程中也会运行一些叫做 生命周期钩子 的函数，这给了用户在不同阶段添加自己的代码的机会。
（ps：生命周期钩子就是生命周期函数）例如，如果要通过某些插件操作DOM节点，如想在页面渲染完后弹出广告窗， 那我们最早可在mounted 中进行。

## <h2 id="22">2.第一次页面加载会触发哪几个钩子？</h2>

答：beforeCreate， created， beforeMount， mounted

## <h2 id="15">3.简述每个周期具体适合哪些场景</h2>

答：  
beforeCreate：在new一个vue实例后，只有一些默认的生命周期钩子和默认事件，其他的东西都还没创建。
在beforeCreate生命周期执行的时候，data和methods中的数据都还没有初始化。不能在这个阶段使用data中的数据和methods中的方法   

created：data 和 methods都已经被初始化好了，如果要调用 methods 中的方法，或者操作 data 中的数据，最早可以在这个阶段中操作  

beforeMount：执行到这个钩子的时候，在内存中已经编译好了模板了，但是还没有挂载到页面中，此时，页面还是旧的  

mounted：执行到这个钩子的时候，就表示Vue实例已经初始化完成了。此时组件脱离了创建阶段，进入到了运行阶段。
如果我们想要通过插件操作页面上的DOM节点，最早可以在和这个阶段中进行  (可以再这个时候发送一些网络请求)

beforeUpdate： 当执行这个钩子时，页面中的显示的数据还是旧的，data中的数据是更新后的， 页面还没有和最新的数据保持同步  

updated：页面显示的数据和data中的数据已经保持同步了，都是最新的

beforeDestory：Vue实例从运行阶段进入到了销毁阶段，这个时候上所有的 data 和 methods ， 指令， 过滤器 ……都是处于可用状态。还没有真正被销毁
(这个时候通常会关闭一些定时器的使用)

destroyed： 这个时候上所有的 data 和 methods ， 指令， 过滤器 ……都是处于不可用状态。组件已经被销毁了。


## <h2 id="23">4.created和mounted的区别</h2>

答：  
created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。  
mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。

## <h2 id="24">5.vue获取数据在哪个周期函数</h2>

答：一般 created/beforeMount/mounted 皆可.  
比如如果你要操作 DOM , 那肯定 mounted 时候才能操作.

## <h2 id="25">6.请详细说下你对vue生命周期的理解？</h2>

答：  
总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。  

创建前/后： 在beforeCreated阶段，vue实例的挂载元素 $ el和数据对象data都为undefined， 还未初始化。  
在created阶段，vue实例的数据对象data有了，$ el还没有。  

载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点， data.message还未替换。
在mounted阶段，vue实例挂载完成，data.message成功渲染。  

更新前/后：当data变化时，会触发beforeUpdate和updated方法。  

销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在。


# <h1 id="three">三、vue路由面试题 </h1>

## <h2 id="26">1.mvvm 框架是什么？</h2>

答：  
vue是实现了双向数据绑定的mvvm框架，当视图改变更新模型层，当模型层改变更新视图层。
在vue中，使用了双向绑定技术，就是View的变化能实时让Model发生变化，而Model的变化也能实时更新到View。

## <h2 id="27">2.vue-router 是什么?它有哪些组件</h2>

答：vue用来写路由一个插件。<font color="red">router-link、router-view</font> 

## <h2 id="28">3.active-class 是哪个组件的属性？</h2>

答：vue-router模块的router-link组件。children数组来定义子路由

## <h2 id="29">4.怎么定义 vue-router 的动态路由? 怎么获取传过来的值？</h2>

答：在router目录下的index.js文件中，对path属性加上/:id。 使用router对象的params.id。

## <h2 id="31">5.vue-router 有哪几种导航钩子?</h2>

答：三种，
第一种：是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截。
第二种：组件内的钩子
第三种：单独路由独享组件

## <h2 id="32">6.$route 和 $router 的区别</h2>

答：   
router是VueRouter的实例，在script标签中想要导航到不同的URL,
使用router.push方法。返回上一个历史history用$router.to(-1)

$route为当前router跳转对象。里面可以获取当前路由的name,path,query,parmas等。

## <h2 id="33">7.vue-router的两种模式</h2>

答:

hash模式：即地址栏 URL 中的 # 符号；

history模式：window.history对象打印出来可以看到里边提供的方法和记录长度。 
利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。（需要特定浏览器支持）。


## <h2 id="34">8.vue-router实现路由懒加载（ 动态加载路由 ）</h2>

答:  
三种方式  

第一种：vue异步组件技术 ==== 异步加载，vue-router配置路由 , 使用vue的异步组件技术 ,
可以实现按需加载 .但是,这种情况下一个组件生成一个js文件。  

第二种：路由懒加载(使用import)。    

第三种：webpack提供的require.ensure()，vue-router配置路由，使用webpack的require.ensure技术，也可以实现按需加载。
这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。  

# <h1 id="four">四, vuex常见面试题</h1>

## <h2 id="35">1.vuex是什么？怎么使用？哪种功能场景使用它？</h2>

答：vue框架中状态管理。在main.js引入store，注入。

新建了一个目录store.js，…… export 。  

场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车


## <h2 id="36">2.vuex有哪几种属性？</h2>

答：   
有五种，分别是 State、 Getter、Mutation 、Action、 Module  
state => 基本数据(数据源存放地)  
getters => 从基本数据派生出来的数据  
mutations => 提交更改数据的方法，同步！  
actions => 像一个装饰器，包裹mutations，使之可以异步。   
modules => 模块化Vuex  

## <h2 id="37">3.Vue.js中ajax请求代码应该写在组件的methods中还是vuex的actions中？</h2>

答：   
如果请求来的数据是不是要被其他组件公用，仅仅在请求的组件内使用，就不需要放入vuex 的state里。  
如果被其他地方复用，这个很大几率上是需要的，如果需要，请将请求放入action里，方便复用。   


## <h2 id="38"></h2>
## <h2 id="39"></h2>
## <h2 id="40"></h2>
## <h2 id="40"></h2>
## <h2 id="40"></h2>
## <h2 id="40"></h2>
## <h2 id="40"></h2>
## <h2 id="40"></h2>
## <h2 id="40"></h2>













