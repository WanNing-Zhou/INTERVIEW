## 001 后端接口轮询

当我们需要做轮询的时候,自然就想到了定时器`setInterval`可以重复执行;
过了一段时间网路波动就会导致定时器不是那'准时',`setInterval`的一个弊端


setInterval的作用是每隔一段指定时间执行一个函数,但是这个执行并不是时间到了就立即执行,
它真正的作用是每隔一段时间`将时间加入时间队列中去`,只有当前的执行栈为空的时候,才能去从
事件队列中取出事件执行;所以可能出现这样的状况;,激素hi当前执行栈执行的时间很长,
`导致事件队列里边积累多个定时器加入的事件,当执行栈结束的时候,这些事件会短时间内连续触发`,
因此不能到间隔一段事件执行的效果,并且可能会造成性能问题,这就是`setIntervel`的`累积效应`

### setInterval的性能问题

1. 对自己调用的代码是否会报错会无视掉,即使调用的代码即使有错误也会继续执行下去
2. setInterval无视网络延迟  
我们在向服务器轮询的数据的时候,如果发生网络卡顿的情况,客户端接收到请求响应的时间大于interval循环的时间;
   而setInterval会无视任何情况下继续定时执行,这就会导致了用户的客户端里充斥着客户端的请求  
   
3. 如果你调用的函数需要花费较长是啊金才能完成,那某些调用会被直接忽略掉

**解决方案:**

使用`setTimeout`代替`setInterval`  
针对setInterval的这个缺点,我们可以使用setTimeout`递归调用`来模拟setInterval;
我们就可以确保只有一个事件结束了,我们看才会触发下一个定时器事件,这样就解决了setInterval问题
```js
var timer;
function func(args){
  //函数本身的逻辑
  // ...
  //函数执行完后，重置定时器
  timer = setTimeout(func, 100, args);
}
timer = setTimeout(func, 100, args);

// 异步请求接口情况
function poll() {
    setTimeout(function() {
        $.get("/path/to/server", function(data, status) {
            console.log(data);
            // 前端接收到后端返回的数据时发起下一次请求
            poll();
        });
    }, 10000);
}

```

实际上由于浏览器的一些机制(垃圾回收,js是到单线程)也无法做到很精确的执行;
浏览器会将最小的超时事件固定在4ms到15ms之间

### 延伸扩展 

**setTime轮询不足**  
- 因为客户端以固定的频率请求服务器是,当数据更新较快的时候,无法获取到最新的数据;
当数据更新较慢的时候,又会进行无意义的请求连接
  
- 因此每次连接都要建立新的`tcp握手挥手`,因此建立Tcp连接时非常消耗资源,网络负载比较大

#### webscoket实现

**websocket 简介**:  

WebSocket 连接本质上就是一个TCP连接; 和http协议同属于应用层;浏览器通过JAvaScript向服务器发送
建立WebSocket连接的请求,连接建立以后,客户端和服务端就可以通过TCP连接直接交换数据,
实现了浏览器和客户端双工通信,并且这个连接会持续存在直到客户端或服务器端的某一方
主动的关闭连接:只需要建立一次连接

**websocket特点**:  
1. 于HTTP协议有着良好的兼容性,莫尔尼端口也是80和443,并且握手采用HTTP协议,因此握手时不容易屏蔽,能通过各种HTTP代理服务器
2. 建立TCP协议基础上,和http协议同属于应用层
3. 数据格式比较轻量,性能开销小,通信高效
4. 可以发送文本,也可以发送二进制数据
5. 没有同源限制,客户端可以与任意服务器通信(实现跨域方法之一)
6. 协议表示符时ws(如果加密,则为wss),服务器网址就是URL,如`ws://localhost:8023`




